{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global[\"fast-copy\"] = factory());\n})(this, function () {\n  'use strict';\n\n  var toStringFunction = Function.prototype.toString;\n  var create = Object.create,\n      defineProperty = Object.defineProperty,\n      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n      getOwnPropertyNames = Object.getOwnPropertyNames,\n      getOwnPropertySymbols = Object.getOwnPropertySymbols,\n      getPrototypeOf$1 = Object.getPrototypeOf;\n  var _a = Object.prototype,\n      hasOwnProperty = _a.hasOwnProperty,\n      propertyIsEnumerable = _a.propertyIsEnumerable;\n  var SYMBOL_PROPERTIES = typeof getOwnPropertySymbols === 'function';\n  var WEAK_MAP = typeof WeakMap === 'function';\n  /**\n   * @function createCache\n   *\n   * @description\n   * get a new cache object to prevent circular references\n   *\n   * @returns the new cache object\n   */\n\n  var createCache = function () {\n    if (WEAK_MAP) {\n      return function () {\n        return new WeakMap();\n      };\n    }\n\n    var Cache =\n    /** @class */\n    function () {\n      function Cache() {\n        this._keys = [];\n        this._values = [];\n      }\n\n      Cache.prototype.has = function (key) {\n        return !!~this._keys.indexOf(key);\n      };\n\n      Cache.prototype.get = function (key) {\n        return this._values[this._keys.indexOf(key)];\n      };\n\n      Cache.prototype.set = function (key, value) {\n        this._keys.push(key);\n\n        this._values.push(value);\n      };\n\n      return Cache;\n    }();\n\n    return function () {\n      return new Cache();\n    };\n  }();\n  /**\n   * @function getCleanClone\n   *\n   * @description\n   * get an empty version of the object with the same prototype it has\n   *\n   * @param object the object to build a clean clone from\n   * @param realm the realm the object resides in\n   * @returns the empty cloned object\n   */\n\n\n  var getCleanClone = function getCleanClone(object, realm) {\n    var prototype = object.__proto__ || getPrototypeOf$1(object);\n\n    if (!prototype) {\n      return create(null);\n    }\n\n    var Constructor = prototype.constructor;\n\n    if (Constructor === realm.Object) {\n      return prototype === realm.Object.prototype ? {} : create(prototype);\n    }\n\n    if (~toStringFunction.call(Constructor).indexOf('[native code]')) {\n      try {\n        return new Constructor();\n      } catch (_a) {}\n    }\n\n    return create(prototype);\n  };\n  /**\n   * @function getObjectCloneLoose\n   *\n   * @description\n   * get a copy of the object based on loose rules, meaning all enumerable keys\n   * and symbols are copied, but property descriptors are not considered\n   *\n   * @param object the object to clone\n   * @param realm the realm the object resides in\n   * @param handleCopy the function that handles copying the object\n   * @returns the copied object\n   */\n\n\n  var getObjectCloneLoose = function getObjectCloneLoose(object, realm, handleCopy, cache) {\n    var clone = getCleanClone(object, realm); // set in the cache immediately to be able to reuse the object recursively\n\n    cache.set(object, clone);\n\n    for (var key in object) {\n      if (hasOwnProperty.call(object, key)) {\n        clone[key] = handleCopy(object[key], cache);\n      }\n    }\n\n    if (SYMBOL_PROPERTIES) {\n      var symbols = getOwnPropertySymbols(object);\n\n      for (var index = 0, length_1 = symbols.length, symbol = void 0; index < length_1; ++index) {\n        symbol = symbols[index];\n\n        if (propertyIsEnumerable.call(object, symbol)) {\n          clone[symbol] = handleCopy(object[symbol], cache);\n        }\n      }\n    }\n\n    return clone;\n  };\n  /**\n   * @function getObjectCloneStrict\n   *\n   * @description\n   * get a copy of the object based on strict rules, meaning all keys and symbols\n   * are copied based on the original property descriptors\n   *\n   * @param object the object to clone\n   * @param realm the realm the object resides in\n   * @param handleCopy the function that handles copying the object\n   * @returns the copied object\n   */\n\n\n  var getObjectCloneStrict = function getObjectCloneStrict(object, realm, handleCopy, cache) {\n    var clone = getCleanClone(object, realm); // set in the cache immediately to be able to reuse the object recursively\n\n    cache.set(object, clone);\n    var properties = SYMBOL_PROPERTIES ? getOwnPropertyNames(object).concat(getOwnPropertySymbols(object)) : getOwnPropertyNames(object);\n\n    for (var index = 0, length_2 = properties.length, property = void 0, descriptor = void 0; index < length_2; ++index) {\n      property = properties[index];\n\n      if (property !== 'callee' && property !== 'caller') {\n        descriptor = getOwnPropertyDescriptor(object, property);\n\n        if (descriptor) {\n          // Only clone the value if actually a value, not a getter / setter.\n          if (!descriptor.get && !descriptor.set) {\n            descriptor.value = handleCopy(object[property], cache);\n          }\n\n          try {\n            defineProperty(clone, property, descriptor);\n          } catch (error) {\n            // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n            clone[property] = descriptor.value;\n          }\n        } else {\n          // In extra edge cases where the property descriptor cannot be retrived, fall back to\n          // the loose assignment.\n          clone[property] = handleCopy(object[property], cache);\n        }\n      }\n    }\n\n    return clone;\n  };\n  /**\n   * @function getRegExpFlags\n   *\n   * @description\n   * get the flags to apply to the copied regexp\n   *\n   * @param regExp the regexp to get the flags of\n   * @returns the flags for the regexp\n   */\n\n\n  var getRegExpFlags = function getRegExpFlags(regExp) {\n    var flags = '';\n\n    if (regExp.global) {\n      flags += 'g';\n    }\n\n    if (regExp.ignoreCase) {\n      flags += 'i';\n    }\n\n    if (regExp.multiline) {\n      flags += 'm';\n    }\n\n    if (regExp.unicode) {\n      flags += 'u';\n    }\n\n    if (regExp.sticky) {\n      flags += 'y';\n    }\n\n    return flags;\n  }; // utils\n\n\n  var isArray = Array.isArray;\n  var getPrototypeOf = Object.getPrototypeOf;\n\n  var GLOBAL_THIS = function () {\n    if (typeof globalThis !== 'undefined') {\n      return globalThis;\n    }\n\n    if (typeof self !== 'undefined') {\n      return self;\n    }\n\n    if (typeof window !== 'undefined') {\n      return window;\n    }\n\n    if (typeof global !== 'undefined') {\n      return global;\n    }\n\n    if (console && console.error) {\n      console.error('Unable to locate global object, returning \"this\".');\n    }\n\n    return this;\n  }();\n  /**\n   * @function copy\n   *\n   * @description\n   * copy an value deeply as much as possible\n   *\n   * If `strict` is applied, then all properties (including non-enumerable ones)\n   * are copied with their original property descriptors on both objects and arrays.\n   *\n   * The value is compared to the global constructors in the `realm` provided,\n   * and the native constructor is always used to ensure that extensions of native\n   * objects (allows in ES2015+) are maintained.\n   *\n   * @param value the value to copy\n   * @param [options] the options for copying with\n   * @param [options.isStrict] should the copy be strict\n   * @param [options.realm] the realm (this) value the value is copied from\n   * @returns the copied value\n   */\n\n\n  function copy(value, options) {\n    // manually coalesced instead of default parameters for performance\n    var isStrict = !!(options && options.isStrict);\n    var realm = options && options.realm || GLOBAL_THIS;\n    var getObjectClone = isStrict ? getObjectCloneStrict : getObjectCloneLoose;\n    /**\n     * @function handleCopy\n     *\n     * @description\n     * copy the value recursively based on its type\n     *\n     * @param value the value to copy\n     * @returns the copied value\n     */\n\n    var handleCopy = function handleCopy(value, cache) {\n      if (!value || typeof value !== 'object') {\n        return value;\n      }\n\n      if (cache.has(value)) {\n        return cache.get(value);\n      }\n\n      var prototype = value.__proto__ || getPrototypeOf(value);\n      var Constructor = prototype && prototype.constructor; // plain objects\n\n      if (!Constructor || Constructor === realm.Object) {\n        return getObjectClone(value, realm, handleCopy, cache);\n      }\n\n      var clone; // arrays\n\n      if (isArray(value)) {\n        // if strict, include non-standard properties\n        if (isStrict) {\n          return getObjectCloneStrict(value, realm, handleCopy, cache);\n        }\n\n        clone = new Constructor();\n        cache.set(value, clone);\n\n        for (var index = 0, length_1 = value.length; index < length_1; ++index) {\n          clone[index] = handleCopy(value[index], cache);\n        }\n\n        return clone;\n      } // dates\n\n\n      if (value instanceof realm.Date) {\n        return new Constructor(value.getTime());\n      } // regexps\n\n\n      if (value instanceof realm.RegExp) {\n        clone = new Constructor(value.source, value.flags || getRegExpFlags(value));\n        clone.lastIndex = value.lastIndex;\n        return clone;\n      } // maps\n\n\n      if (realm.Map && value instanceof realm.Map) {\n        clone = new Constructor();\n        cache.set(value, clone);\n        value.forEach(function (value, key) {\n          clone.set(key, handleCopy(value, cache));\n        });\n        return clone;\n      } // sets\n\n\n      if (realm.Set && value instanceof realm.Set) {\n        clone = new Constructor();\n        cache.set(value, clone);\n        value.forEach(function (value) {\n          clone.add(handleCopy(value, cache));\n        });\n        return clone;\n      } // blobs\n\n\n      if (realm.Blob && value instanceof realm.Blob) {\n        return value.slice(0, value.size, value.type);\n      } // buffers (node-only)\n\n\n      if (realm.Buffer && realm.Buffer.isBuffer(value)) {\n        clone = realm.Buffer.allocUnsafe ? realm.Buffer.allocUnsafe(value.length) : new Constructor(value.length);\n        cache.set(value, clone);\n        value.copy(clone);\n        return clone;\n      } // arraybuffers / dataviews\n\n\n      if (realm.ArrayBuffer) {\n        // dataviews\n        if (realm.ArrayBuffer.isView(value)) {\n          clone = new Constructor(value.buffer.slice(0));\n          cache.set(value, clone);\n          return clone;\n        } // arraybuffers\n\n\n        if (value instanceof realm.ArrayBuffer) {\n          clone = value.slice(0);\n          cache.set(value, clone);\n          return clone;\n        }\n      } // if the value cannot / should not be cloned, don't\n\n\n      if ( // promise-like\n      typeof value.then === 'function' || // errors\n      value instanceof Error || // weakmaps\n      realm.WeakMap && value instanceof realm.WeakMap || // weaksets\n      realm.WeakSet && value instanceof realm.WeakSet) {\n        return value;\n      } // assume anything left is a custom constructor\n\n\n      return getObjectClone(value, realm, handleCopy, cache);\n    };\n\n    return handleCopy(value, createCache());\n  } // Adding reference to allow usage in CommonJS libraries compiled using TSC, which\n  // expects there to be a default property on the exported value. See\n  // [#37](https://github.com/planttheidea/fast-copy/issues/37) for details.\n\n\n  copy.default = copy;\n  /**\n   * @function strictCopy\n   *\n   * @description\n   * copy the value with `strict` option pre-applied\n   *\n   * @param value the value to copy\n   * @param [options] the options for copying with\n   * @param [options.realm] the realm (this) value the value is copied from\n   * @returns the copied value\n   */\n\n  copy.strict = function strictCopy(value, options) {\n    return copy(value, {\n      isStrict: true,\n      realm: options ? options.realm : void 0\n    });\n  };\n\n  return copy;\n});","map":{"version":3,"mappings":"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","names":["toStringFunction","Function","prototype","toString","Object","defineProperty","getOwnPropertyDescriptor","getOwnPropertyNames","getOwnPropertySymbols","getPrototypeOf","hasOwnProperty","propertyIsEnumerable","SYMBOL_PROPERTIES","WEAK_MAP","WeakMap","createCache","_keys","_values","Cache","has","key","indexOf","get","value","push","getCleanClone","object","realm","__proto__","create","Constructor","constructor","call","getObjectCloneLoose","handleCopy","cache","clone","set","symbols","index","length_1","length","symbol","getObjectCloneStrict","properties","concat","length_2","property","descriptor","error","getRegExpFlags","regExp","flags","global","ignoreCase","multiline","unicode","sticky","Array","GLOBAL_THIS","globalThis","self","window","console","copy","options","isStrict","getObjectClone","isArray","Date","getTime","RegExp","source","lastIndex","Map","forEach","Set","add","Blob","slice","size","type","Buffer","isBuffer","allocUnsafe","ArrayBuffer","isView","buffer","then","Error","WeakSet","default","strict","strictCopy"],"sources":["/Users/273488/Workspace/My Repo/Code Reference/MyPics/node_modules/src/utils.ts","/Users/273488/Workspace/My Repo/Code Reference/MyPics/node_modules/src/index.ts"],"sourcesContent":["const { toString: toStringFunction } = Function.prototype;\nconst {\n  create,\n  defineProperty,\n  getOwnPropertyDescriptor,\n  getOwnPropertyNames,\n  getOwnPropertySymbols,\n  getPrototypeOf,\n} = Object;\nconst { hasOwnProperty, propertyIsEnumerable } = Object.prototype;\n\nconst SYMBOL_PROPERTIES = typeof getOwnPropertySymbols === 'function';\nconst WEAK_MAP = typeof WeakMap === 'function';\n\n/**\n * @function createCache\n *\n * @description\n * get a new cache object to prevent circular references\n *\n * @returns the new cache object\n */\nexport const createCache = (() => {\n  if (WEAK_MAP) {\n    return (): FastCopy.Cache => new WeakMap();\n  }\n\n  class Cache {\n    _keys: any[] = [];\n    _values: any[] = [];\n\n    has(key: any) {\n      return !!~this._keys.indexOf(key);\n    }\n\n    get(key: any) {\n      return this._values[this._keys.indexOf(key)];\n    }\n\n    set(key: any, value: any) {\n      this._keys.push(key);\n      this._values.push(value);\n    }\n  }\n\n  return (): FastCopy.Cache => new Cache();\n})();\n\n/**\n * @function getCleanClone\n *\n * @description\n * get an empty version of the object with the same prototype it has\n *\n * @param object the object to build a clean clone from\n * @param realm the realm the object resides in\n * @returns the empty cloned object\n */\nexport const getCleanClone = (object: any, realm: FastCopy.Realm): any => {\n  const prototype = object.__proto__ || getPrototypeOf(object);\n\n  if (!prototype) {\n    return create(null);\n  }\n\n  const Constructor = prototype.constructor;\n\n  if (Constructor === realm.Object) {\n    return prototype === realm.Object.prototype ? {} : create(prototype);\n  }\n\n  if (~toStringFunction.call(Constructor).indexOf('[native code]')) {\n    try {\n      return new Constructor();\n    } catch {}\n  }\n\n  return create(prototype);\n};\n\n/**\n * @function getObjectCloneLoose\n *\n * @description\n * get a copy of the object based on loose rules, meaning all enumerable keys\n * and symbols are copied, but property descriptors are not considered\n *\n * @param object the object to clone\n * @param realm the realm the object resides in\n * @param handleCopy the function that handles copying the object\n * @returns the copied object\n */\nexport const getObjectCloneLoose: FastCopy.ObjectCloner = (\n  object: any,\n  realm: FastCopy.Realm,\n  handleCopy: FastCopy.Copier,\n  cache: FastCopy.Cache,\n): any => {\n  const clone: any = getCleanClone(object, realm);\n\n  // set in the cache immediately to be able to reuse the object recursively\n  cache.set(object, clone);\n\n  for (const key in object) {\n    if (hasOwnProperty.call(object, key)) {\n      clone[key] = handleCopy(object[key], cache);\n    }\n  }\n\n  if (SYMBOL_PROPERTIES) {\n    const symbols: symbol[] = getOwnPropertySymbols(object);\n\n    for (\n      let index = 0, length = symbols.length, symbol;\n      index < length;\n      ++index\n    ) {\n      symbol = symbols[index];\n\n      if (propertyIsEnumerable.call(object, symbol)) {\n        clone[symbol] = handleCopy(object[symbol], cache);\n      }\n    }\n  }\n\n  return clone;\n};\n\n/**\n * @function getObjectCloneStrict\n *\n * @description\n * get a copy of the object based on strict rules, meaning all keys and symbols\n * are copied based on the original property descriptors\n *\n * @param object the object to clone\n * @param realm the realm the object resides in\n * @param handleCopy the function that handles copying the object\n * @returns the copied object\n */\nexport const getObjectCloneStrict: FastCopy.ObjectCloner = (\n  object: any,\n  realm: FastCopy.Realm,\n  handleCopy: FastCopy.Copier,\n  cache: FastCopy.Cache,\n): any => {\n  const clone: any = getCleanClone(object, realm);\n\n  // set in the cache immediately to be able to reuse the object recursively\n  cache.set(object, clone);\n\n  const properties: (string | symbol)[] = SYMBOL_PROPERTIES\n    ? getOwnPropertyNames(object).concat(\n        getOwnPropertySymbols(object) as unknown as string[],\n      )\n    : getOwnPropertyNames(object);\n\n  for (\n    let index = 0, length = properties.length, property, descriptor;\n    index < length;\n    ++index\n  ) {\n    property = properties[index];\n\n    if (property !== 'callee' && property !== 'caller') {\n      descriptor = getOwnPropertyDescriptor(object, property);\n\n      if (descriptor) {\n        // Only clone the value if actually a value, not a getter / setter.\n        if (!descriptor.get && !descriptor.set) {\n          descriptor.value = handleCopy(object[property], cache);\n        }\n\n        try {\n          defineProperty(clone, property, descriptor);\n        } catch (error) {\n          // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n          clone[property] = descriptor.value;\n        }\n      } else {\n        // In extra edge cases where the property descriptor cannot be retrived, fall back to\n        // the loose assignment.\n        clone[property] = handleCopy(object[property], cache);\n      }\n    }\n  }\n\n  return clone;\n};\n\n/**\n * @function getRegExpFlags\n *\n * @description\n * get the flags to apply to the copied regexp\n *\n * @param regExp the regexp to get the flags of\n * @returns the flags for the regexp\n */\nexport const getRegExpFlags = (regExp: RegExp): string => {\n  let flags = '';\n\n  if (regExp.global) {\n    flags += 'g';\n  }\n\n  if (regExp.ignoreCase) {\n    flags += 'i';\n  }\n\n  if (regExp.multiline) {\n    flags += 'm';\n  }\n\n  if (regExp.unicode) {\n    flags += 'u';\n  }\n\n  if (regExp.sticky) {\n    flags += 'y';\n  }\n\n  return flags;\n};\n","// utils\nimport {\n  createCache,\n  getObjectCloneLoose,\n  getObjectCloneStrict,\n  getRegExpFlags,\n} from './utils';\n\nconst { isArray } = Array;\nconst { getPrototypeOf } = Object;\n\nconst GLOBAL_THIS: FastCopy.Realm = (function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  if (console && console.error) {\n    console.error('Unable to locate global object, returning \"this\".');\n  }\n\n  return this;\n})();\n\n/**\n * @function copy\n *\n * @description\n * copy an value deeply as much as possible\n *\n * If `strict` is applied, then all properties (including non-enumerable ones)\n * are copied with their original property descriptors on both objects and arrays.\n *\n * The value is compared to the global constructors in the `realm` provided,\n * and the native constructor is always used to ensure that extensions of native\n * objects (allows in ES2015+) are maintained.\n *\n * @param value the value to copy\n * @param [options] the options for copying with\n * @param [options.isStrict] should the copy be strict\n * @param [options.realm] the realm (this) value the value is copied from\n * @returns the copied value\n */\nfunction copy<Value>(value: Value, options?: FastCopy.Options): Value {\n  // manually coalesced instead of default parameters for performance\n  const isStrict = !!(options && options.isStrict);\n  const realm = (options && options.realm) || GLOBAL_THIS;\n  const getObjectClone = isStrict ? getObjectCloneStrict : getObjectCloneLoose;\n\n  /**\n   * @function handleCopy\n   *\n   * @description\n   * copy the value recursively based on its type\n   *\n   * @param value the value to copy\n   * @returns the copied value\n   */\n  const handleCopy: FastCopy.Copier = (\n    value: any,\n    cache: FastCopy.Cache,\n  ): any => {\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n\n    if (cache.has(value)) {\n      return cache.get(value);\n    }\n\n    const prototype = value.__proto__ || getPrototypeOf(value);\n    const Constructor = prototype && prototype.constructor;\n\n    // plain objects\n    if (!Constructor || Constructor === realm.Object) {\n      return getObjectClone(value, realm, handleCopy, cache);\n    }\n\n    let clone: any;\n\n    // arrays\n    if (isArray(value)) {\n      // if strict, include non-standard properties\n      if (isStrict) {\n        return getObjectCloneStrict(value, realm, handleCopy, cache);\n      }\n\n      clone = new Constructor();\n      cache.set(value, clone);\n\n      for (\n        let index: number = 0, length = value.length;\n        index < length;\n        ++index\n      ) {\n        clone[index] = handleCopy(value[index], cache);\n      }\n\n      return clone;\n    }\n\n    // dates\n    if (value instanceof realm.Date) {\n      return new Constructor(value.getTime());\n    }\n\n    // regexps\n    if (value instanceof realm.RegExp) {\n      clone = new Constructor(\n        value.source,\n        value.flags || getRegExpFlags(value),\n      );\n\n      clone.lastIndex = value.lastIndex;\n\n      return clone;\n    }\n\n    // maps\n    if (realm.Map && value instanceof realm.Map) {\n      clone = new Constructor();\n      cache.set(value, clone);\n\n      value.forEach((value: any, key: any) => {\n        clone.set(key, handleCopy(value, cache));\n      });\n\n      return clone;\n    }\n\n    // sets\n    if (realm.Set && value instanceof realm.Set) {\n      clone = new Constructor();\n      cache.set(value, clone);\n\n      value.forEach((value: any) => {\n        clone.add(handleCopy(value, cache));\n      });\n\n      return clone;\n    }\n\n    // blobs\n    if (realm.Blob && value instanceof realm.Blob) {\n      return value.slice(0, value.size, value.type);\n    }\n\n    // buffers (node-only)\n    if (realm.Buffer && realm.Buffer.isBuffer(value)) {\n      clone = realm.Buffer.allocUnsafe\n        ? realm.Buffer.allocUnsafe(value.length)\n        : new Constructor(value.length);\n\n      cache.set(value, clone);\n      value.copy(clone);\n\n      return clone;\n    }\n\n    // arraybuffers / dataviews\n    if (realm.ArrayBuffer) {\n      // dataviews\n      if (realm.ArrayBuffer.isView(value)) {\n        clone = new Constructor(value.buffer.slice(0));\n        cache.set(value, clone);\n        return clone;\n      }\n\n      // arraybuffers\n      if (value instanceof realm.ArrayBuffer) {\n        clone = value.slice(0);\n        cache.set(value, clone);\n        return clone;\n      }\n    }\n\n    // if the value cannot / should not be cloned, don't\n    if (\n      // promise-like\n      typeof value.then === 'function' ||\n      // errors\n      value instanceof Error ||\n      // weakmaps\n      (realm.WeakMap && value instanceof realm.WeakMap) ||\n      // weaksets\n      (realm.WeakSet && value instanceof realm.WeakSet)\n    ) {\n      return value;\n    }\n\n    // assume anything left is a custom constructor\n    return getObjectClone(value, realm, handleCopy, cache);\n  };\n\n  return handleCopy(value, createCache());\n}\n\n// Adding reference to allow usage in CommonJS libraries compiled using TSC, which\n// expects there to be a default property on the exported value. See\n// [#37](https://github.com/planttheidea/fast-copy/issues/37) for details.\ncopy.default = copy;\n\n/**\n * @function strictCopy\n *\n * @description\n * copy the value with `strict` option pre-applied\n *\n * @param value the value to copy\n * @param [options] the options for copying with\n * @param [options.realm] the realm (this) value the value is copied from\n * @returns the copied value\n */\ncopy.strict = function strictCopy(value: any, options?: FastCopy.Options) {\n  return copy(value, {\n    isStrict: true,\n    realm: options ? options.realm : void 0,\n  });\n};\n\nexport default copy;\n"]},"metadata":{},"sourceType":"script"}